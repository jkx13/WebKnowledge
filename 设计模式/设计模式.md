## 单例模式
	保证一个类只有一个实例，并提供一个全局访问变量，比如线程池/全局缓存/浏览器window对象等。
例如弹窗实现(createSingle管理单例对象，闭包存储实例只创建一个弹窗实例)
```javascript
var createSingle = (function () {
    let instance = {};
    return function (fn) {
        if (!instance[fn.name]) {
            instance[fn.name] = fn.apply(this, arguments);
        }

        return instance[fn.name];
    }
})();
var createLoginLarger = () => {
    let div = document.createElement('div');
    div.innerHTML = '弹窗';
    div.style.display = 'none';

    document.body.appendChild(div);

    return div;
};

document.getElementById('btn').onclick = () => {
    const loginlayer = createSingle(createLoginLarger);
    loginlayer.style.display = 'block';
}
```

## 策略模式
	将一个一个的策略方法分别封装起来(具体算法和计算过程及算法的实现和算法的使用是分离的，代码清晰职责明确)，可以相互替换
例如计算不同业绩水平的年终奖励(分不同业绩水平A/B/C为工资的多少倍)
```javascript
const strategies = {
	A:(salary)=>salary*3,
	B:(salary)=>salary*2,
	C:(salary)=>salary*1
}

const calculateBonus = (level,salary)=>{
	return strategies[level](salary);
}

calculateBonus('A',19000);
```

## 代理模式
	就是实现一个对象的代理对象，用户访问对象实际访问的是代理对象。
例如外卖送花
```javascript
const Flower = function(){return '花🌹'};

//男孩
const goodBoy = {
	sendFlower:function(target){
		const flower = Flower();
		target.receiveFlower(flower);
	}
}

//女孩
const goodGirl = {
	receiveFlower:function(flower){
		console.log(`收到${flower}哇～`);
	},
	myAddress:function(){
		return new Promise((resovle,reject)=>{
			resovle('女孩地址是XXX')
		})
	}
}

//外卖小哥
const takeMan = {
	receiveFlower:function(flower){
		goodGirl.myAddress().then((address)=>{
			console.log(address);
			goodGirl.receiveFlower(flower);
		})
	}
}

goodBoy.sendFlower(takeMan);

```
大图片加载空白使用代理加载
```javascript
const imgNode = (function () {
    const img = document.createElement('img');
    document.body.appendChild(img);
    return {
        setSrc: function (src) {
            img.src = src;
        }
    }
})();

const loadingImg = './loading.gif'//加载图片
const imageSrc = 'http://www.xxx.com/j.png'//原图访问

const proxyImg = (function () {
    const image = new Image();
    image.onload = function () {
        imgNode.setSrc(image.src);
    }
    return {
        setSrc: function (src) {
            imgNode.setSrc(loadingImg);
            image.src = src;
        }
    }
})();

proxyImg.setSrc(imgageSrc);
```